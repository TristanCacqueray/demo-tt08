/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.8.1. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input wire  CLK // clock


      // Outputs
    , output wire signed [7:0] OUT
    );
  wire  c$bindCsr;
  // SoundPlayer.hs:124:1-9
  reg [15:0] r = 16'd0;
  wire signed [31:0] c$app_arg;
  wire signed [31:0] c$app_arg_0;
  wire signed [63:0] c$app_arg_1;
  wire signed [63:0] result;
  wire signed [31:0] c$sawOsc_$jOut_app_arg;
  wire signed [31:0] c$sawOsc_$jOut_case_alt;
  wire [16:0] z;
  wire [15:0] result_0;
  wire signed [31:0] c$dividend;
  wire signed [31:0] c$dividend_0;

  // resetGen begin
  // pragma translate_off
  reg  rst;
  localparam reset_period = 226757360 - 10 + (1 * 226757360);
  `ifndef VERILATOR
  initial begin
    #1 rst =  1 ;
    #reset_period rst =  0 ;
  end
  `else
  always begin
    // The redundant (rst | ~ rst) is needed to ensure that this is
    // calculated in every cycle by verilator. Without it, the reset will stop
    // being updated and will be stuck as asserted forever.
    rst = $c("this->reset_gen(",reset_period,",true)") & (rst | ~ rst);
  end
  `systemc_interface
  CData reset_gen(vluint32_t reset_period, bool active_high) {
    static vluint32_t to_wait = reset_period;
    static CData reset = active_high ? 1 : 0;
    static bool finished = false;

    if(!finished) {
      if(to_wait == 0) {
        reset = reset == 0 ? 1 : 0;
        finished = true;
      }
      else {
        to_wait = to_wait - 1;
      }
    }

    return reset;
  }
  `verilog
  `endif
  assign c$bindCsr = rst;
  // pragma translate_on
  // resetGen end

  // register begin
  always @(posedge CLK or  posedge  c$bindCsr) begin : r_register
    if ( c$bindCsr) begin
      r <= 16'd0;
    end else begin
      r <= result_0;
    end
  end
  // register end

  assign OUT = $signed(result[0+:8]);

  assign c$dividend = (c$app_arg_0 * 32'sd255);

  // divSigned begin
  wire resultPos;
  wire dividerNeg;
  wire signed [32:0] dividend2;
  wire signed [32:0] dividendE;
  wire signed [32:0] dividerE;
  wire signed [32:0] quot_res;

  assign resultPos = c$dividend[32-1] == c$sawOsc_$jOut_app_arg[32-1];
  assign dividerNeg = c$sawOsc_$jOut_app_arg[32-1] == 1'b1;
  assign dividendE = $signed({{c$dividend[32-1]},c$dividend});  // sign extension
  assign dividerE = $signed({{c$sawOsc_$jOut_app_arg[32-1]} ,c$sawOsc_$jOut_app_arg} );  // sign extension

  assign dividend2 = resultPos ? dividendE
                           : (dividerNeg ? (dividendE - dividerE - 32'sd1)
                                      : (dividendE - dividerE + 32'sd1));

  assign quot_res = dividend2 / dividerE;
  assign c$app_arg = $signed(quot_res[32-1:0]);
  // divSigned end

  assign c$dividend_0 = ($signed(c$app_arg_1[0+:32]));

  // modSigned begin
  // remainder
  wire signed [31:0] rem_res;
  assign rem_res = c$dividend_0 % c$sawOsc_$jOut_app_arg;

  // modulo
  assign c$app_arg_0 = (c$dividend_0[32-1] == c$sawOsc_$jOut_app_arg[32-1]) ?
                   rem_res :
                   (rem_res == 32'sd0 ? 32'sd0 : rem_res + c$sawOsc_$jOut_app_arg);
  // modSigned end

  assign c$app_arg_1 = $unsigned({{(64-16) {1'b0}},r});

  assign result = $signed({{(64-32) {1'b0}},c$app_arg});

  assign c$sawOsc_$jOut_app_arg = (r > 16'd20000) ? 32'sd88 : c$sawOsc_$jOut_case_alt;

  assign c$sawOsc_$jOut_case_alt = (r > 16'd12000) ? 32'sd91 : 32'sd100;

  assign z = r + 16'd1;

  assign result_0 = (z > 17'd44099) ? 16'd0 : (z[0+:16]);


endmodule

